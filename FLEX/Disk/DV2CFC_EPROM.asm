;*   ELEKTOR EC6809 DISK DRIVER
;*   INTO I/O EPROM LOCATED AT $E800
;*   WITH AT LEAST TWO PAGES OF 512 BYTES
;*
;*   THIS VERSION CAN MANAGE TWO CF LOCATED AT $EE80 & $EEF0
;*   AND MAPPED AS DISK 2 & 3 RESPECTIVELY.
;*
;*   08/2024 PH. ROEHR

;*   ESS540 EPROM ROUTINES ADDRESS

EREAD       EQU     $F006
EWRITE      EQU     $F009
ERESTO      EQU     $F00F
EDRSEL      EQU     $F012
ESEEK       EQU     $F003
EINIT       EQU     $F01E
EVERIF      EQU     $F015
ETEMPO      EQU     $F206
EINITAB     EQU     $F01E
RESET       EQU     $FFFE

;* FLEX EQUATES

INPBUF      EQU     $C080   ; FLEX INPUT BUFFER ADDRESS
PRCNT       EQU     $CC34   ; PRINTER RUNNING FLAG

;*   CF REGS

CF1ADDRES   EQU     $EE80
CF2ADDRES   EQU     $EEF0
CFDATA      EQU     $00     ; DATA PORT
CFERROR     EQU     $01     ; ERROR CODE (READ)
CFFEATURE   EQU     $01     ; FEATURE SET (WRITE)
CFSECCNT    EQU     $02     ; NUMBER OF SECTORS TO TRANSFER
CFLBA0      EQU     $03     ; SECTOR ADDRESS LBA 0 [0:7]
CFLBA1      EQU     $04     ; SECTOR ADDRESS LBA 1 [8:15]
CFLBA2      EQU     $05     ; SECTOR ADDRESS LBA 2 [16:23]
CFLBA3      EQU     $06     ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
CFSTATUS    EQU     $07     ; STATUS (READ)
CFCOMMAND   EQU     $07     ; COMMAND SET (WRITE)

;*   VARIOUS ADDRESSES

ROMLATCH    EQU     $EEB0
CFBUFF      EQU     $EA00   ; PAGINED RAM BASE ADDRESS
CMDAD1      EQU     $C100
CMDAD2      EQU     $C200
DREAD       EQU     $DE00   ; BEGIN OF FLEX DISK ROUTINES JUMP TABLE

CFDSKNB1    EQU     $02     ; DISK NUMBER USED IN FLEX FOR CF 1 AT $EE80 !! = 2 ON EC-6809 !!
CFDSKNB2    EQU     $03     ; DISK NUMBER USED IN FLEX FOR CF 2 AT $EEF0 !! = 3 ON EC-6809 !!

;*   PARAM TABLE FOR ESS540 EPROM AND CF OPERATIONS
;*   $DE80 -> DE91  RESERVED AS ESS540 EPROM DISK OPERATIONS
;*   $DE92 -> DEAF  RESERVED AS ESS540 EPROM DISPLAY OPERATIONS
;*   $DEB0 -> DEC3  RESERVED AS PARAMETERS FOR CF OPERATIONS

DSKTAB   EQU     $DE80
CFOK     EQU     $DEB0         ; FLAG CF PRESENT TWO CF = 2 / ONE CF = 1 / NO CF = 0
CFSEL    EQU     CFOK+1        ; FLEX SELECTED CF 0 = CF EE80 / 1 = CF EEF0
LBA0     EQU     CFOK+2
LBA1     EQU     CFOK+3
LBA2     EQU     CFOK+4        ; ALWAYS 0 UNDER FLEX
LBA3     EQU     CFOK+5        ; CLEAR LBA3, SET MASTER & LBA MODE
CFTRK    EQU     CFOK+6        ; TRACK ASKED BY FLEX FOR CF
CFSEC    EQU     CFOK+7        ; SECTOR ASKED BY FLEX FOR CF
CFMTRK   EQU     CFOK+8        ; TRACKS MAX ON SELECTED CF
CFMSEC   EQU     CFOK+9        ; SECTORS/TRACK MAX ON SELECTED CF
CF1MTRK  EQU     CFOK+10       ; TRACKS MAX ON CF1
CF1MSEC  EQU     CFOK+11       ; SECTORS PER TRACK ON CF1
CF2MTRK  EQU     CFOK+12       ; TRACKS MAX ON CF2
CF2MSEC  EQU     CFOK+13       ; SECTORS PER TRACK ON CF2
CFADDRES EQU     CFOK+14       ; SELECTED CF ADDRESS
CFSTATUL EQU     CFOK+16       ; SELECTED CF STATUS ADDRESS 16 BITS
CFSEC16  EQU     CFOK+18       ; SELECTED CF SECTOR NUMBER 16 BITS

;*   FLEX DISK ROUTINE JUMP TABLE ADDRESSES FOR FLOPPY AND CF

FLTAB   EQU     CFOK+20
CFTAB   EQU     CFOK+28

;*   WHERE TO STORE JUMP ADDRESS IN CASE OF CALL OF ROUTINE IN OTHER EPROM PAGE

JMPADR  EQU     CFOK+36

;*   ELEKTOR EC6809 DISK DRIVER
;*   EPROM PAGE 0
;*   05/2024 PH. ROEHR

;* ALL ROUTINES BELOW WILL BE LOCATED IN LOWER PAGE OF I/O BOARD EPROM
;* EPROM PAGE CAN BE SELECTED WITH LATCH AT $EEB0

        ORG     $E800

        RPT     $E830-$E800
        FCB     $00

;*   THIS ROUTINE PREPARE THE STACK BEFORE PAGE CHANGE
;*   AT CALL Y MUST BE = TO RETURN ADDRESS AND
;*   JMPADR SHOULD CONTAIN THE ROUTINE ADDRESS IN THE OTHER PAGE

CALLRT0 PSHS     Y               ; STORE RETURN ADDRESS (IN PAGE 0)
        LDY      #CHGPA1         ; PAGE 1 ROUTINES SHOULD COME BACK TO CHGPA1 AFTER RTS
        PSHS     Y               ; SO PUT THIS ON STACK
        LDY      JMPADR          ; LOAD JUMP ADDRESS ROUTINE
        PSHS     Y

;* ROUTINE CALL FOR OTHER EPROM PAGE
;* THIS ROUTINE ALWAYS ASSUME THAT WE GO BACK TO PAGE 1

CHGPA0  PSHS    B,CC        ; STORE B AND CC
        LDB     #$01        ; PREPARE FOR PAGE 1
;* BEFORE GOING TO PAGE 1 ENABLE IRQ & FIRQ
        ANDCC   #$AF        ; %10101111
        STB     ROMLATCH    ; SET ROM PAGE 1
        NOP                 ; WAIT A LITTLE
;* FOLLOWING INSTRUCTION MUST BE STRICTLY ALIGNED TO THE SAME ADDRESS BETWEEN THE 2 PAGES $E848
        PULS    B,CC,Y      ; RESTORE B CC AND ADDRESS TO GO
        TFR     Y,PC        ; JUMP TO ROUTINE

;*   INITIALISE CF'S CARD WITH TIMEOUT
;*   IF CF PRESENT READ SIR AND STORE GEOM PARAMETERS
;*   !! THE CF IS DETECTED BUT NO WARNING IF NOT FORMATTED !!

E0INCF  LDX     #$00FF          ; PREPARE FOR TIMEOUT
        LDD     #$00E0          ; PREPARE LBA2 & LBA3
        STD     LBA2
INIT0   LDB     [CFSTATUL]      ; READ THE CF STATUS REGISTER
        BITB    #%10000000      ; ISOLATE THE BUSY BIT
        BEQ     INIT1           ; IF BIT CLEAR CF OK CONTINUE
        LEAX    -1,X            ; COUNTDOWN
        BNE     INIT0           ; NOT FINISH TRY AGAIN
        ANDCC   #%11111011      ; NO RESPONSE CLEAR Z
        RTS                     ; THEN RETURN
INIT1   LDX     CFADDRES        ; CF PRESENT PERFORM INIT AND READ GEOM
        LDB     #$04            ; RESET THE CF CARD
        STB     CFCOMMAND,X
        JSR     CMDWAI0
        LDB     LBA3            ; CLEAR LBA3, SET MASTER & LBA MODE
        STB     CFLBA3,X
        JSR     CMDWAI0
        LDB     #$01            ; SET 8-BIT BUS WIDTH
        STB     CFFEATURE,X
        JSR     CMDWAI0
        LDB     #$01            ; READ ONLY ONE SECTOR AT A TIME.
        STB     CFSECCNT,X
        JSR     CMDWAI0
        LDB     #$EF            ; ENABLE FEATURES
        STB     CFCOMMAND,X
        JSR     CMDWAI0
        BSR     CFERR0
        BNE     ENDINIT         ; CF NOT OK - RETURN WITH Z CLEAR
        LDD     #$0200          ; READ SIR - SIR LBA0-LBA1 NUMBERS
        STD     LBA0            ; SO LBA IS SET TO E0-00-00-02
        LDX     #CFBUFF         ; A TEMPORARY PLACE TO PUT THE DATA
;* E1RDB01 READ SECTOR ROUTINE CALL ON EPROM PAGE 1
        LDY     #E1RDBO1        ; GO TO READ SECTOR IN OTHER EPROM PAGE
        STY     JMPADR          ; STORE ROUTINE ADDRESS IN RAM
        LDY     #*+6            ; LOAD A RETURN ADDRESS
        BRA     CALLRT0         ; GO TO PREPARE STACK AND JUMP
;* END ROUTINE CALL
        LDD     38,X            ; LOAD CF MAX TRK & SEC PARAMS FROM BUFFER
        STD     CFMTRK          ; STORE INTO TABLE
        ORCC    #%00000100      ; CF PRESENT AND OK SET Z
ENDINIT RTS                     ; RETURN WITH Z SET IF ALL OK

;*   ERROR INITIALIZING THE CF CARD (B0 SET IF ERROR)
;*   RETURN WITH Z CLEAR IF ERROR

CFERR0  LDB     [CFSTATUL]      ; READ THE STATUS REGISTER
        BITB    #%00000001      ; THEN ISOLATE THE ERROR BIT B0
        RTS                     ; RETURN WITH Z SET IF NO ERROR

;*   WAIT FOR CF CARD NOT BUSY
;*   CHECK FOR BSY = 0 (BIT 7)

DATWAI0 LDB     [CFSTATUL]      ; READ THE STATUS REGISTER
        BITB    #%10000000      ; ISOLATE THE BUSY BIT
        BNE     DATWAI0         ; WAIT BUSY BIT CLEAR
        RTS

;*   WAIT FOR CF CARD READY
;*   CHECK FOR BSY = 0 (BIT 7) THEN FOR RDY = 1 (BIT 6)

CMDWAI0 BSR     DATWAI0         ; CHECK BSY NOT SET
CMD10   LDB     [CFSTATUL]      ; READ THE STATUS REGISTER
        BITB    #%01000000      ; ISOLATE READY BIT - READY IF B6=1
        BEQ     CMD10           ; WAIT READY BIT SET
        RTS

;*   LOAD CF BOOT SECTOR AND JUMP

E0CFBT  CLR     CFOK                    ; CLEAR CF PRESENT FLAG
        CLRB                            ; PREPARE FOR FLOPPY 6 MS STEP RATE
        JSR     EINITAB                 ; PREPARE PARAMS & TABLE FOR FLOPPY OPERATIONS IN ESS540
        JSR     E0CHKCF                 ; CHECK AND INIT CF 1 & 2
        TST     CFOK
        BEQ     REBOOT                  ; NO CF 1 FOUND AT INIT - REBOOT
        LDX     #CMDAD1
        LDD     #$0000                  ; PREPARE FOR TR0S1 (LBA 0000)
        STD     LBA0
        STD     $01FE,X                 ; STORE SOMETHING WHERE THE 'FLEX' STRING
        STD     $00FE,X                 ; SHOULD BE FOUND AFTER TR0S1 AND TR0S2 READ
        BSR     CHKFLX
        BNE     REBOOT                  ; NO 'FLEX' STRING AT END OF TR0S1 - REBOOT
        LDX     #CMDAD2
        LDD     #$0100                  ; PREPARE FOR TR0S2
        STD     LBA0
        BSR     CHKFLX
        BNE     JMP1                    ; NO 'FLEX' STRING AT END OF TR0S2 - GO TO CMDAD1
        LDS     #INPBUF
        JMP     CMDAD2                  ; BOOT LAY ON 2 SECTORS - GO TO CMDAD2
JMP1    LDS     #INPBUF
        JMP     CMDAD1
REBOOT  JMP     [RESET]                 ; NO CF OR NO 'FLEX' STRING FOUND - RESET

;* LOAD TRACK AND CHECK 'FLEX' IS IN MEMORY - RETURN Z=0 IF NOT FOUND

;* E1RDB01 READ SECTOR ROUTINE CALL ON EPROM PAGE 1
CHKFLX  LDY     #E1RDBO1                ; GO TO READ SECTOR IN OTHER EPROM PAGE
        STY     JMPADR                  ; STORE ROUTINE ADDRESS IN RAM
        LDY     #*+7                    ; LOAD A RETURN ADDRESS
        JMP     CALLRT0                 ; GO TO PREPARE STACK AND JUMP
;* END ROUTINE CALL
        LDD     $00FE,X
        CMPD    #$4558                  ; COMPARE TO 'EX'
        BNE     ENDCKFX
        LDD     $00FC,X
        CMPD    #$464C                  ; COMPARE TO 'FL'
ENDCKFX RTS

;*   CHECK IF CF 1 & 2 PRESENT
;*   CFOK=0 IF NO CF - CFOK=1 IF ONLY CF 1 PRESENT - CFOK=2 IF CF 1 & 2 PRESENT

E0CHKCF CLR     CFOK
        BSR     E0SCF1
        JSR     E0INCF
        BNE     ENDCHK          ; TEST Z SET CF 1 PRESENT - IF NOT DONT CHECK FOR CF 2
        LDD     CFMTRK          ; STORE CF 1 PARAMETERS IN TABLE
        STD     CF1MTRK
        INC     CFOK            ; CF 1 PRESENT INC CFOK TO 1
        BSR     E0SCF2          ; TEST IF CF 2 PRESENT
        JSR     E0INCF
        BNE     PRPCF1          ; IF NOT PRESENT JUST PREPARE FOR CF 1 & RETURN
        LDD     CFMTRK          ; STORE CF 2 PARAMETERS IN TABLE
        STD     CF2MTRK
        INC     CFOK            ; CF 2 IS PRESENT INC CFOK TO 2
PRPCF1  BSR     E0SCF1          ; AFTER INIT PREPARE TABLE FOR CF 1 TO BE READY FOR BOOT FROM
ENDCHK  RTS

;*   SET CF 1 PARAMETERS

E0SCF1  PSHS    A,B,X
        LDX     #CF1ADDRES
        LDD     CF1MTRK
        BRA     STORCF

;*   SET CF 2 PARAMETERS

E0SCF2  PSHS    A,B,X
        LDX     #CF2ADDRES
        LDD     CF2MTRK

;*   AND STORE IN TABLE

STORCF  STX     CFADDRES        ; SET CF ADDRESS FOR CF
        STD     CFMTRK          ; STORE TRACK & SECTOR FOR CF
        LDA     #CFSTATUS       ; COMPUTE STATUS LONG ADDRESS FOR CF
        LEAX    A,X
        STX     CFSTATUL        ; STORE
        PULS    A,B,X,PC        ; RETURN

;* MOVE DISK DRIVER JUMP TABLE
;* X = ADDRESS OF TABLE TO BE MOVED
;* Y = DESTINATION ADDRESS

E0MVT   PSHS    A
E0MVT1  LDD     ,X++        ; CHANGE READ/WRITE/VERIF
        STD     ,Y
        LEAY    3,Y
        CMPY    #DREAD+(3*3)+1
        BNE     E0MVT1
        LDD     ,X          ; CHANGE SEEK
        STD     18,Y
        PULS    A,PC

;*   DRIVE   THE SPECIFIED DRIVE IS TO BE SELECTED. THE DRIVE IS SPECIFIED
;*           IN THE FCB POINTED TO BY THE CONTENTS OF THE X REGISTER. NOTE
;*           THAT THE DRIVE NUMBER IS THE 4TH BYTE OF THE FCB.

;*           ENTRY - (X) = FCB ADDRESS (3,X CONTAINS DRIVE NUMBER)

;*           EXIT -  (X) MAY BE DESTROYED
;*                   (A) MAY BE DESTROYED
;*                   (B) = $0F IF NON-EXISTENT DRIVE
;*                       = ERROR CONDITION OTHERWISE
;*                   (Z) = 1 IF NO ERROR
;*                       = 0 IF AN ERROR
;*                   (C) = 0 IF NO ERROR
;*                       = 1 IF AN ERROR

E0DRV   PSHS    U,X,Y,A,B
        LDY     #DREAD+1
        BSR     E0TSTCF
        BEQ     CF
;* FLOPPY CASE
        LDX     #FLTAB          ; MOVE JUMP TABLE FOR FLOPPY OPERATIONS
        BSR     E0MVT
        LDU     #DSKTAB
        JSR     EDRSEL          ; JUMP TO ESS540 EPROM
        BRA     ENDDRV
;* COMPACT FLASH CASE
CF      TST     CFOK            ; CHECK IF CF PRESENT
        BEQ     NOCF            ; CF NOT PRESENT - GO TO SET ERROR
        CMPA    #CFDSKNB2       ; IS CF 2 ASKED (DISK 3) ?
        BNE     CF1             ; NO THEN ITS CF 1 (DISK 2)
        LDA     CFOK
        CMPA    #$02            ; IF CF 2 ASKED CHECK IF PRESENT (CFOK = 2 ?)
        BNE     NOCF            ; IF NOT SET ERROR DISK NOT PRESENT
        BSR     E0SCF2          ; SET CF 2 PARAMETERS
        BRA     ENDCF
CF1     BSR     E0SCF1          ; SET CF 1 PARAMETERS
ENDCF   LDX     #CFTAB          ; MOVE TABLE FOR CF OPERATIONS
        BSR     E0MVT
        CLRB                    ; CLEAR B SET Z CLEAR C
        BRA     ENDDRV
;* COMPACT FLASH ASKED BUT NOT PRESENT
NOCF    LDB     #$0F            ; SET ERROR FOR NON EXISTENT DRIVE - CLEAR Z
        ORCC    #$01            ; ERROR - MUST SET C=1
ENDDRV  PULS    U,X,Y,A,B,PC

;* TEST IF DISK NUMBER STORED AT 3,X IS CF1 (DISK 3) OR CF2 (DISK 2)
;* RETURN Z=1 IF YES
;* RETURN A=DISK

E0TSTCF LDA     3,X
        CMPA    #CFDSKNB2       ; CHECK IF CF 2 REQUIRED
        BEQ     E0ENDTS         ; IF YES TEST FINISHED, RETURN
        CMPA    #CFDSKNB1       ; IF NOT CF 2 TEST IF CF 1
E0ENDTS RTS

;* FILL WITH $00 TO END OF PAGE

        RPT    $EA00-*
        FCB    $00


;* ---------------------------------------------------------------------
;* ---------------------------------------------------------------------
;* ---------------------------------------------------------------------


;*   ELEKTOR EC6809 DISK DRIVER
;*   EPROM PAGE 1
;*   08/2024 PH. ROEHR

;* ALL ROUTINES BELOW WILL BE LOCATED IN PAGE 1 OF I/O BOARD EPROM
;* EPROM PAGE CAN BE SELECTED WITH LATCH LOCATED AT $EEB0
;* THESE ROUTINES WILL BE EXECUTED RELOCATED AT $E800

        PHASE   $E800

;* JUMP TABLE INTO EPROM ROUTINES
;* WITH THIS TABLE WE CAN USE FIXED ADDRESSES FOR ROUTINES CALL
;* FORM OUTSIDE OF THE EPROM EVEN IN CASE OF MODIFICATIONS
;* NOT ALL ROUTINES ARE LISTED HERE, ONLY USEFULL ONES

SEEK    JMP     E1SEEK
READ    JMP     E1READ
WRITE   JMP     E1WRIT
VERIF   JMP     E1VERIF
RST     JMP     E1RST
DRV     JMP     E1DRV
CHKRDY  JMP     E1CHRDY
QUICK   JMP     E1QUICK
CHKCF   JMP     E1CHKCF
RDCFSEC JMP     E1RSEC
WRCFSEC JMP     E1WSEC
CFSEEK  JMP     E1CFSEK
CFVRFY  JMP     E1CFVRY
CFBOOT  JMP     E1CFBT
RDBOOT  JMP     E1RDBOT

;*   THIS ROUTINE PREPARE THE STACK BEFORE PAGE CHANGE
;*   AT CALL Y MUST BE = TO RETURN ADDRESS AND
;*   JMPADR SHOULD CONTAIN THE ROUTINE ADDRESS TO GO IN THE OTHER PAGE

CALLRT1 PSHS     Y          ; STORE RETURN ADDRESS (IN PAGE 1)
        LDY      #CHGPA0    ; PAGE 0 ROUTINES SHOULD COME BACK TO CHGPA0 AFTER RTS
        PSHS     Y          ; SO PUT THIS ON STACK
        LDY      JMPADR     ; LOAD JUMP ADDRESS ROUTINE (IN PAGE 0)
        PSHS     Y

;*   ROUTINE CALL FOR OTHER PAGE
;*   THIS ROUTINE ALWAYS ASSUME THAT WE GO TO PAGE 0

CHGPA1  PSHS    B,CC        ; STORE B AND CC
        LDB     #%00        ; PREPARE FOR PAGE 0
;* CHECK IF AND PROCESS BATCH PRINTING
        JSR     INTER
;* BEFORE GOING TO PAGE 0 DISABLE IRQ & FIRQ
        ORCC    #$50        ; %01010000
        STB     ROMLATCH    ; SET ROM PAGE 0
        NOP                 ; WAIT A LITLLE
;* FOLLOWING INSTRUCTION MUST BE STRICTLY ALIGNED TO THE SAME ADDRESS BETWEEN THE 2 PAGES $E848
        PULS    B,CC,Y      ; RESTORE B CC AND ADDRESS TO GO
        TFR     Y,PC        ; JUMP TO ROUTINE

;*   SEEK    SEEKS TO THE TRACK SPECIFIED IN THE 'A' ACCUMULATOR. IN
;*           DOUBLE-SIDED SYSTEMS, THIS ROUTINE SHOULD ALSO SELECT THE
;*           CORRECT SIDE DEPENDING ON THE SECTOR NUMBER SUPPLIED IN 'B'.
;*
;*           ENTRY - (A) = TRACK NUMBER
;*                   (B) = SECTOR NUMBER
;*
;*           EXIT -  (X) MAY BE DESTROYED (SEE TEXT)
;*                   (A) MAY BE DESTROYED (SEE TEXT)
;*                   (B) = ERROR CONDITION
;*                   (Z) = 1 IF NO ERROR
;*                       = 0 IF AN ERROR

E1SEEK  PSHS    U,Y
        LDU     #DSKTAB
        JSR     ESEEK       ; JUMP TO ESS540 EPROM
        PULS    U,Y,PC

;*   READ    THIS ROUTINE READS THE SPECIFIED SECTOR INTO MEMORY AT THE
;*           SPECIFIED ADDRESS. THIS ROUTINE SHOULD PERFORM A SEEK
;*           OPERATION IF NECESSARY. A SECTOR IS 256 BYTES IN LENGTH.
;*
;*           ENTRY - (X) = ADDRESS IN MEMORY WHERE SECTOR IS TO BE PLACED.
;*                   (A) = TRACK NUMBER
;*                   (B) = SECTOR NUMBER
;*
;*           EXIT -  (X) MAY BE DESTROYED
;*                   (A) MAY BE DESTROYED
;*                   (B) = ERROR CONDITION
;*                   (Z) = 1 IF NO ERROR
;*                       = 0 IF AN ERROR

E1READ  PSHS    U,Y
        JSR    INTER
        LDU     #DSKTAB
        JSR     EREAD       ; JUMP TO ESS540 EPROM
        PULS    U,Y,PC

;*   WRITE   THIS ROUTINE WRITES THE INFORMATION FROM THE SPECIFED MEMORY
;*           BUFFER AREA TO THE DISK SECTOR SPECIFIED. THIS ROUTINE SHOULD
;*           PERFORM A SEEK OPERATION IF NECESSARY. A SECTOR IS 256 BYTES
;*           IN LENGTH.
;*
;*           ENTRY - (X) = ADDRESS OF 256 BYTES MEMORY BUFFER CONTAINING
;*                         DATA TO BE WRITTEN TO DISK
;*                   (A) = TRACK NUMBER
;*                   (B) = SECTOR NUMBER
;*
;*           EXIT -  (X) MAY BE DESTROYED
;*                   (A) MAY BE DESTROYED
;*                   (B) = ERROR CONDITION
;*                   (Z) = 1 IF NO ERROR
;*                       = 0 IF AN ERROR

E1WRIT  PSHS    U,Y
        JSR     INTER
        LDU     #DSKTAB
        JSR     EWRITE      ; JUMP TO ESS540 EPROM
        PULS    U,Y,PC

;*   VERIFY  THE SECTOR JUST WRITTEN TO THE DISK IS TO BE VERIFIED TO
;*           DETERMINE IF THERE ARE CRC ERRORS. NO SEEK IS REQUIRED AS
;*           THIS ROUTINE WILL ONLY BE CALLED IMMEDIATELY AFTER A WRITE
;*           SINGLE SECTOR OPERATION.
;*
;*           ENTRY - NO ENTRY PARAMETERS
;*
;*           EXIT -  (X) MAY BE DESTROYED
;*                   (A) MAY BE DESTROYED
;*                   (B) = ERROR CONDITION
;*                   (Z) = 1 IF NO ERROR
;*                       = 0 IF AN ERROR

E1VERIF PSHS    A,U,Y
        JSR     INTER
        LDU     #DSKTAB
        JSR     EVERIF      ; JUMP TO ESS540 EPROM
        PULS    A,U,Y,PC

;*   RESTORE A RESTORE OPERATION (ALSO KNOWN AS A "SEEK TO TRACK 00") IS TO
;*           BE PERFORMED ON THE SPECIFIED DRIVE. THE DRIVE IS SPECIFIED
;*           IN THE FCB POINTED TO BY THE CONTENTS OF THE X REGISTER. NOTE
;*           THAT THE DRIVE NUMBER IS THE 4TH BYTE OF THE FCB. THIS
;*           ROUTINE SHOULD SELECT THE DRIVE BEFORE EXECUTING THE RESTORE
;*           OPERATION.

;*           ENTRY - (X) = FCB ADDRESS (3,X CONTAINS DRIVE NUMBER)

;*           EXIT -  (X) MAY BE DESTROYED
;*                   (A) MAY BE DESTROYED
;*                   (B) = ERROR CONDITION
;*                   (Z) = 1 IF NO ERROR
;*                       = 0 IF AN ERROR

E1RST   BSR     E1DRV           ; MAKE DRIVE SELECT
        BSR     E1TSTCF
        BNE     RSTFLP
        RTS                     ; RETURN
RSTFLP  PSHS    U,Y             ; FLOPPY SELECTED NOW DO RESTORE
        LDU     #DSKTAB
        LDA     3,X
        JSR     ERESTO          ; JUMP TO ESS540 EPROM
        PULS    U,Y,PC

;*   DRIVE   THE SPECIFIED DRIVE IS TO BE SELECTED. THE DRIVE IS SPECIFIED
;*           IN THE FCB POINTED TO BY THE CONTENTS OF THE X REGISTER. NOTE
;*           THAT THE DRIVE NUMBER IS THE 4TH BYTE OF THE FCB.

;*           ENTRY - (X) = FCB ADDRESS (3,X CONTAINS DRIVE NUMBER)

;*           EXIT -  (X) MAY BE DESTROYED
;*                   (A) MAY BE DESTROYED
;*                   (B) = $0F IF NON-EXISTENT DRIVE
;*                       = ERROR CONDITION OTHERWISE
;*                   (Z) = 1 IF NO ERROR
;*                       = 0 IF AN ERROR
;*                   (C) = 0 IF NO ERROR
;*                       = 1 IF AN ERROR
;*
;* ROUTINE LOCATED IN PAGE 0
;*

E1DRV   LDY      #E0DRV         ; LOAD JUMP ADDRESS
        STY      JMPADR         ; STORE
        LDY      #*+6           ; PREPARE A RETURN ADDRESS - RTS JUST BELOW
        BRA      CALLRT1        ; GO TO PREPARE STACK AND JUMP
        RTS

;* TEST IF DISK NUMBER STORED AT 3,X IS CF1 (DISK 3) OR CF2 (DISK 2)
;* RETURN Z=1 IF YES
;* RETURN A=DISK

E1TSTCF LDA     3,X
        CMPA    #CFDSKNB2       ; CHECK IF CF 2 REQUIRED
        BEQ     ENDTST          ; IF YES TEST FINISHED, RETURN
        CMPA    #CFDSKNB1       ; IF NOT CF 2 TEST IF CF 1
ENDTST  RTS

;*   CHKRDY  CHECK FOR A DRIVE READY CONDITION. THE DRIVE NUMBER IS FOUND
;*           IN THE SPECIFIED FCB (AT 3,X). IF THE USER'S CONTROLLER TURNS
;*           THE DRIVE MOTORS OFF AFTER SOME TIME DELAY, THIS ROUTINE
;*           SHOULD FIRST CHECK FOR A DRIVE READY CONDITION AND IF IT IS
;*           NOT READY, SHOULD DELAY LONG ENOUGH FOR THE MOTORS TO COME UP
;*           TO SPEED, THEN CHECK AGAIN. THIS DELAY SHOULD BE DONE ONLY IF
;*           NOT READY ON THE FIRST TRY AND ONLY IF NECESSARY FOR THE
;*           PARTICULAR DRIVES AND CONTROLLER! IF THE HARDWARE ALWAYS
;*           LEAVES THE DRIVE MOTORS ON, THIS ROUTINE SHOULD PERFORM A
;*           SINGLE CHECK FOR DRIVE READY AND IMMEDIATELY RETURN THE
;*           RESULTING STATUS. SYSTEMS WHICH DO NOT HAVE THE ABILITY TO
;*           CHECK FOR A DRIVE READY CONDITION SHOULD SIMPLY ALWAYS RETURN
;*           A READY STATUS IF THE DRIVE NUMBER IS VALID.

;*           ENTRY - (X) = FCB ADDRESS (3,X CONTAINS DRIVE NUMBER)

;*           EXIT -  (X) MAY BE DESTROYED
;*                   (A) MAY BE DESTROYED
;*                   (B) = ERROR CONDITION
;*                   (Z) = 1 IF DRIVE READY
;*                       = 0 IF NOT READY
;*                   (C) = 0 IF DRIVE READY
;*                       = 1 IF NOT READY

E1CHRDY BSR     E1TSTCF
        BNE     FLP        ; NO CONTINUE AS FLOPPY
        BRA     E1CFRDY
FLP     CMPA    #$01       ; CHECK DRIVE 0 -> 1
        BLS     TEST       ; IF DRIVE NUMBER OK MAKE A DELAY
        BRA     NRDY       ; IF NOT GOTO ERROR CODE SET AND RETURN
;*  MAKE A LONG DELAY
TEST    LDX     #$0FFF
TEST1   JSR     ETEMPO
        LEAX    -1,X
        BNE     TEST1
        BRA     OK         ; END OF DELAY JUMP TO CLRB AND RETURN

;*   QUICK   THIS ROUTINE PERFORMS A "QUICK" DRIVE READY CHECK. ITS
;*           FUNCTION IS EXACTLY LIKE THE CHKRDY ROUTINE ABOVE EXCEPT THAT
;*           NO DELAY SHOULD BE DONE. IF THE DRIVE DOES NOT GIVE A READY
;*           CONDITION ON THE FIRST CHECK, A NOT READY CONDITION IS
;*           IMMEDIATELY RETURNED. ENTRY AND EXIT ARE AS ABOVE.

E1QUICK BSR     E1TSTCF
        BNE     QFLP       ; NO CONTINUE AS FLOPPY
        BRA     E1CFRDY    ; GOTO CF READY ROUTINE
QFLP    CMPA    #$01       ; CHECK DRIVE 0 -> 1
        BLS     OK
NRDY    LDB     #$80       ; LOAD CODE ERROR AND CLEAR Z
        ORCC    #$01       ; SET C
        RTS
OK      CLRB               ; ASSUME READY - SET Z - CLEAR C
        RTS

;* INTERRUPT MANAGEMENT

INTER   TST     PRCNT       ; TEST IF PRINTER RUN
        BEQ     ENDINT
        SWI3                ; GOTO PROCESS SWITCH ROUTINE
        NOP
ENDINT  RTS

;* CF READY CHECK
;* RETURN WITH B= ERROR CODE AND Z=0 AND C=1 IF CF NOT PRESENT

E1CFRDY TST     CFOK       ; TEST IF CF PRESENT
        BEQ     NRDY       ; IF NOT GOTO ERROR CODE SET AND RETURN
        LDA     3,X
        CMPA    #CFDSKNB2  ; IS DISK 3 ASKED ?
        BNE     OK         ; NO THEN ITS DISK 2 AND GO DO DRV READY
        LDB     CFOK       ; DISK 3 IS ASKED SO CFOK MUST BE SET TO 2 ?
        CMPB    #02
        BEQ     OK         ; IF YES OK
        BRA     NRDY       ; CF 3 ASKED BUT CFOK NOT SET TO 2 - DRV NOT READY

;* READ A BLOCK OF DATA FROM THE CF CARD TO MEMORY
;* X = BUFFER BEGIN ADDRESS
;* A = TRACK NUMBER
;* B = SECTOR NUMBER

E1RSEC   STD     CFTRK
         BSR     INTER
         BSR     E1RDBOT
         RTS

;* READ A BLOCK OF DATA FROM THE CF CARD TO MEMORY
;* WITHOUT ANY REFERENCE TO FLEX
;* LOOP UNTIL THE DRQ BIT = 0 (B3)
;* CF BLOCK IS 512 BYTES - ONLY FIRST 256 BYTES STORED IN MEMORY
;* X = BUFFER BEGIN ADDRESS
;* USE LBA NUMBERS STORED AT #LBA0 - ROUTINE ENTRY = E1RDBO1
;* COMPUTE LBA WITH #CFTRK - ROUTINE ENTRY = E1RDBOT

E1RDBOT JSR     COMPLBA
E1RDBO1 PSHS    U,X,Y               ; ENTRY WITH LBA READY AT #LBA0
        ORCC    #$50                ; DISABLE IRQ
        JSR     SETLBA
        LDY     #$0000
        BSR     CMDWAI1
        LDB     #$20                ; SEND READ COMMAND TO THE CF CARD
        STB     [CFSTATUL]
        BSR     DATWAI1
RDBOL1  LDB     [CFADDRES]          ; READ THE DATA BYTE
        CMPY    #256                ; ONLY FIRST 256 BYTES TO BUFFER
        BGE     RDBOL2              ; CONTINUE READ BUT DONT PUT DATA TO BUFFER
        STB     ,X+                 ; WRITE DATA TO BUFFER
        LEAY    1,Y
RDBOL2  BSR     DATWAI1
        LDB     [CFSTATUL]
        BITB    #$08                ; CHECK IF CF SAY READ FINISHED
        BNE     RDBOL1
        CLRB                        ; NO ERROR CODE SET Z CLEAR C
        ANDCC   #$AF                ; ENABLE IRQ
        PULS    U,X,Y,PC            ; RETURN WITH Z=1

;*   WAIT FOR CF CARD NOT BUSY
;*   CHECK FOR BSY = 0 (BIT 7)

DATWAI1 LDB     [CFSTATUL]      ; READ THE STATUS REGISTER
        BITB    #%10000000      ; ISOLATE THE BUSY BIT
        BNE     DATWAI1         ; WAIT BUSY BIT CLEAR
        RTS

;*   WAIT FOR CF CARD READY
;*   CHECK FOR BSY = 0 (BIT 7) THEN FOR RDY = 1 (BIT 6)

CMDWAI1 BSR     DATWAI1         ; CHECK BSY NOT SET
CMD11   LDB     [CFSTATUL]      ; READ THE STATUS REGISTER
        BITB    #%01000000      ; ISOLATE READY BIT - READY IF B6=1
        BEQ     CMD11           ; WAIT READY BIT SET
        RTS

;* WRITE A BLOCK OF DATA FROM MEMORY TO THE CF CARD
;* LOOP UNTIL THE DRQ BIT = 0 (B3)
;* CF BLOCK IS 512 BYTES - ONLY FIRST 256 BYTES OF BUFFER STORED ON CF
;* X = BUFFER BEGIN ADDRESS
;* A = TRACK NUMBER
;* B = SECTOR NUMBER

E1WSEC  PSHS    U,X,Y
        STD     CFTRK               ; STORE TRACK-SECTOR IN TABLE
        BSR     INTER
        ORCC    #$50                ; DISABLE IRQ
        JSR    COMPLBA             ; COMPUTE LBA NUMBER
        JSR    SETLBA
        LDY     #$0000
        BSR     CMDWAI1
        LDB     #$30                ; SEND WRITE COMMAND TO THE CF CARD
        STB     [CFSTATUL]
        BSR     DATWAI1
        LDB     ,X+                 ; READ BYTE FROM BUFFER
WRL1    STB     [CFADDRES]          ; WRITE THE DATA BYTE TO THE CF CARD.
        BSR     DATWAI1
        CMPY    #255                ; ONLY FIRST 256 BYTES GO TO CF
        BGE     WRL2                ; CONTINUE WRITE BUT DONT TAKE DATA FROM BUFFER
        LEAY    1,Y
        LDB     ,X+                 ; READ BYTE FROM BUFFER
WRL2    LDA     [CFSTATUL]
        BITA    #$08                ; CHECK IF CF SAY WRITE FINISHED
        BNE     WRL1
        ANDCC   #$AF                ; ENABLE IRQ
        CLRB                        ; NO ERROR CODE SET Z CLEAR C
        PULS    U,X,Y,PC            ; RETURN WITH Z=1

;* CF SEEK + CF VERIFY
;* RETURN WITH Z=1 AND C=0 SO VERIFY AND SEEK ALWAYS OK

E1CFSEK STD     CFTRK           ; STORE CF TRACK SECTOR NUMBERS IN TABLE
E1CFVRY CLRB                    ; NO ERROR CODE SET Z CLEAR C
        RTS

;* SET LBA VALUES INTO CF REGISTERS

SETLBA  PSHS    X,Y,B
        BSR     CMDWAI1
        LDX     CFADDRES
        LEAX    CFLBA0,X
        LDY     #LBA0
LBAL    LDB     ,Y+             ; LOAD CURRENT LBA FROM TABLE
        STB     ,X+             ; SET LBA IN CF
        BSR     CMDWAI1
        CMPY    #LBA0+4
        BNE     LBAL
        LDB     #$01            ; READ ONLY ONE SECTOR AT A TIME.
        LDX     CFADDRES
        STB     CFSECCNT,X
        BSR     CMDWAI1
        PULS    X,Y,B,PC

;*   COMPUTE LBA WITH TRACK AND SECTOR NUMBERS

COMPLBA PSHS    A,B
        CLR     CFSEC16         ; SET SECTOR AS 16 BITS NUMBER INTO CFSEC16
        LDA     CFSEC
        STA     CFSEC16+1       ; STORE SECTOR NUMBER INTO LSB OF CFSEC16
        LDA     CFTRK           ; LOAD TRACK NUMBER
        LDB     CFMSEC          ; LOAD SECTORS / TRACK
        MUL                     ; MULTIPLY A.B TO A AND B (A MSB)
        ADDD    CFSEC16         ; ADD IT TO D
        DECD                    ; -1
        STB     LBA0
        STA     LBA1
        PULS    A,B,PC

;*   CHECK IF CF 1 + 2 PRESENT
;*   ROUTINE IS ON EPROM PAGE 0

E1CHKCF LDY      #E0CHKCF       ; LOAD JUMP ADDRESS
        STY      JMPADR         ; STORE
        LDY      #*+7           ; PREPARE A RETURN ADDRESS - RTS JUST BELOW
        JMP      CALLRT1        ; GO TO PREPARE STACK AND JUMP
        RTS

;*   LOAD CF BOOT SECTOR AND JUMP
;*   ROUTINE IS ON EPROM PAGE 0

E1CFBT  CLR      PRCNT           ; MUST CLEAR THIS TO AVOID SWI3 AT BOOT
        LDY      #E0CFBT         ; LOAD JUMP ADDRESS ROUTINE
        STY      JMPADR          ; STORE
        LDY      #*+7            ; PREPARE A RETURN ADDRESS - RTS JUST BELOW
        JMP      CALLRT1         ; GO TO PREPARE STACK AND JUMP
        RTS

;* FILL WITH $00 TO END OF PAGE

        RPT      $EA00-*
        FCB      $00


